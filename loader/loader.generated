/* THIS FILE IS GENERATED.  DO NOT EDIT. */

/*
 * XGL
 *
 * Copyright (C) 2014 LunarG, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <xgl.h>
#include <xglDbg.h>

struct icd_dispatch_table {
    XGL_RESULT (XGLAPI *InitAndEnumerateGpus)(const XGL_APPLICATION_INFO* pAppInfo, const XGL_ALLOC_CALLBACKS* pAllocCb, XGL_UINT maxGpus, XGL_UINT* pGpuCount, XGL_PHYSICAL_GPU* pGpus);
    XGL_RESULT (XGLAPI *GetGpuInfo)(XGL_PHYSICAL_GPU gpu, XGL_PHYSICAL_GPU_INFO_TYPE infoType, XGL_SIZE* pDataSize, XGL_VOID* pData);
    XGL_RESULT (XGLAPI *CreateDevice)(XGL_PHYSICAL_GPU gpu, const XGL_DEVICE_CREATE_INFO* pCreateInfo, XGL_DEVICE* pDevice);
    XGL_RESULT (XGLAPI *DestroyDevice)(XGL_DEVICE device);
    XGL_RESULT (XGLAPI *GetExtensionSupport)(XGL_PHYSICAL_GPU gpu, const XGL_CHAR* pExtName);
    XGL_RESULT (XGLAPI *GetDeviceQueue)(XGL_DEVICE device, XGL_QUEUE_TYPE queueType, XGL_UINT queueIndex, XGL_QUEUE* pQueue);
    XGL_RESULT (XGLAPI *QueueSubmit)(XGL_QUEUE queue, XGL_UINT cmdBufferCount, const XGL_CMD_BUFFER* pCmdBuffers, XGL_UINT memRefCount, const XGL_MEMORY_REF* pMemRefs, XGL_FENCE fence);
    XGL_RESULT (XGLAPI *QueueSetGlobalMemReferences)(XGL_QUEUE queue, XGL_UINT memRefCount, const XGL_MEMORY_REF* pMemRefs);
    XGL_RESULT (XGLAPI *QueueWaitIdle)(XGL_QUEUE queue);
    XGL_RESULT (XGLAPI *DeviceWaitIdle)(XGL_DEVICE device);
    XGL_RESULT (XGLAPI *GetMemoryHeapCount)(XGL_DEVICE device, XGL_UINT* pCount);
    XGL_RESULT (XGLAPI *GetMemoryHeapInfo)(XGL_DEVICE device, XGL_UINT heapId, XGL_MEMORY_HEAP_INFO_TYPE infoType, XGL_SIZE* pDataSize, XGL_VOID* pData);
    XGL_RESULT (XGLAPI *AllocMemory)(XGL_DEVICE device, const XGL_MEMORY_ALLOC_INFO* pAllocInfo, XGL_GPU_MEMORY* pMem);
    XGL_RESULT (XGLAPI *FreeMemory)(XGL_GPU_MEMORY mem);
    XGL_RESULT (XGLAPI *SetMemoryPriority)(XGL_GPU_MEMORY mem, XGL_MEMORY_PRIORITY priority);
    XGL_RESULT (XGLAPI *MapMemory)(XGL_GPU_MEMORY mem, XGL_FLAGS flags, XGL_VOID** ppData);
    XGL_RESULT (XGLAPI *UnmapMemory)(XGL_GPU_MEMORY mem);
    XGL_RESULT (XGLAPI *PinSystemMemory)(XGL_DEVICE device, const XGL_VOID* pSysMem, XGL_SIZE memSize, XGL_GPU_MEMORY* pMem);
    XGL_RESULT (XGLAPI *RemapVirtualMemoryPages)(XGL_DEVICE device, XGL_UINT rangeCount, const XGL_VIRTUAL_MEMORY_REMAP_RANGE* pRanges, XGL_UINT preWaitSemaphoreCount, const XGL_QUEUE_SEMAPHORE* pPreWaitSemaphores, XGL_UINT postSignalSemaphoreCount, const XGL_QUEUE_SEMAPHORE* pPostSignalSemaphores);
    XGL_RESULT (XGLAPI *GetMultiGpuCompatibility)(XGL_PHYSICAL_GPU gpu0, XGL_PHYSICAL_GPU gpu1, XGL_GPU_COMPATIBILITY_INFO* pInfo);
    XGL_RESULT (XGLAPI *OpenSharedMemory)(XGL_DEVICE device, const XGL_MEMORY_OPEN_INFO* pOpenInfo, XGL_GPU_MEMORY* pMem);
    XGL_RESULT (XGLAPI *OpenSharedQueueSemaphore)(XGL_DEVICE device, const XGL_QUEUE_SEMAPHORE_OPEN_INFO* pOpenInfo, XGL_QUEUE_SEMAPHORE* pSemaphore);
    XGL_RESULT (XGLAPI *OpenPeerMemory)(XGL_DEVICE device, const XGL_PEER_MEMORY_OPEN_INFO* pOpenInfo, XGL_GPU_MEMORY* pMem);
    XGL_RESULT (XGLAPI *OpenPeerImage)(XGL_DEVICE device, const XGL_PEER_IMAGE_OPEN_INFO* pOpenInfo, XGL_IMAGE* pImage, XGL_GPU_MEMORY* pMem);
    XGL_RESULT (XGLAPI *DestroyObject)(XGL_OBJECT object);
    XGL_RESULT (XGLAPI *GetObjectInfo)(XGL_BASE_OBJECT object, XGL_OBJECT_INFO_TYPE infoType, XGL_SIZE* pDataSize, XGL_VOID* pData);
    XGL_RESULT (XGLAPI *BindObjectMemory)(XGL_OBJECT object, XGL_GPU_MEMORY mem, XGL_GPU_SIZE offset);
    XGL_RESULT (XGLAPI *CreateFence)(XGL_DEVICE device, const XGL_FENCE_CREATE_INFO* pCreateInfo, XGL_FENCE* pFence);
    XGL_RESULT (XGLAPI *GetFenceStatus)(XGL_FENCE fence);
    XGL_RESULT (XGLAPI *WaitForFences)(XGL_DEVICE device, XGL_UINT fenceCount, const XGL_FENCE* pFences, XGL_BOOL waitAll, XGL_UINT64 timeout);
    XGL_RESULT (XGLAPI *CreateQueueSemaphore)(XGL_DEVICE device, const XGL_QUEUE_SEMAPHORE_CREATE_INFO* pCreateInfo, XGL_QUEUE_SEMAPHORE* pSemaphore);
    XGL_RESULT (XGLAPI *SignalQueueSemaphore)(XGL_QUEUE queue, XGL_QUEUE_SEMAPHORE semaphore);
    XGL_RESULT (XGLAPI *WaitQueueSemaphore)(XGL_QUEUE queue, XGL_QUEUE_SEMAPHORE semaphore);
    XGL_RESULT (XGLAPI *CreateEvent)(XGL_DEVICE device, const XGL_EVENT_CREATE_INFO* pCreateInfo, XGL_EVENT* pEvent);
    XGL_RESULT (XGLAPI *GetEventStatus)(XGL_EVENT event);
    XGL_RESULT (XGLAPI *SetEvent)(XGL_EVENT event);
    XGL_RESULT (XGLAPI *ResetEvent)(XGL_EVENT event);
    XGL_RESULT (XGLAPI *CreateQueryPool)(XGL_DEVICE device, const XGL_QUERY_POOL_CREATE_INFO* pCreateInfo, XGL_QUERY_POOL* pQueryPool);
    XGL_RESULT (XGLAPI *GetQueryPoolResults)(XGL_QUERY_POOL queryPool, XGL_UINT startQuery, XGL_UINT queryCount, XGL_SIZE* pDataSize, XGL_VOID* pData);
    XGL_RESULT (XGLAPI *GetFormatInfo)(XGL_DEVICE device, XGL_FORMAT format, XGL_FORMAT_INFO_TYPE infoType, XGL_SIZE* pDataSize, XGL_VOID* pData);
    XGL_RESULT (XGLAPI *CreateImage)(XGL_DEVICE device, const XGL_IMAGE_CREATE_INFO* pCreateInfo, XGL_IMAGE* pImage);
    XGL_RESULT (XGLAPI *GetImageSubresourceInfo)(XGL_IMAGE image, const XGL_IMAGE_SUBRESOURCE* pSubresource, XGL_SUBRESOURCE_INFO_TYPE infoType, XGL_SIZE* pDataSize, XGL_VOID* pData);
    XGL_RESULT (XGLAPI *CreateImageView)(XGL_DEVICE device, const XGL_IMAGE_VIEW_CREATE_INFO* pCreateInfo, XGL_IMAGE_VIEW* pView);
    XGL_RESULT (XGLAPI *CreateColorAttachmentView)(XGL_DEVICE device, const XGL_COLOR_ATTACHMENT_VIEW_CREATE_INFO* pCreateInfo, XGL_COLOR_ATTACHMENT_VIEW* pView);
    XGL_RESULT (XGLAPI *CreateDepthStencilView)(XGL_DEVICE device, const XGL_DEPTH_STENCIL_VIEW_CREATE_INFO* pCreateInfo, XGL_DEPTH_STENCIL_VIEW* pView);
    XGL_RESULT (XGLAPI *CreateShader)(XGL_DEVICE device, const XGL_SHADER_CREATE_INFO* pCreateInfo, XGL_SHADER* pShader);
    XGL_RESULT (XGLAPI *CreateGraphicsPipeline)(XGL_DEVICE device, const XGL_GRAPHICS_PIPELINE_CREATE_INFO* pCreateInfo, XGL_PIPELINE* pPipeline);
    XGL_RESULT (XGLAPI *CreateComputePipeline)(XGL_DEVICE device, const XGL_COMPUTE_PIPELINE_CREATE_INFO* pCreateInfo, XGL_PIPELINE* pPipeline);
    XGL_RESULT (XGLAPI *StorePipeline)(XGL_PIPELINE pipeline, XGL_SIZE* pDataSize, XGL_VOID* pData);
    XGL_RESULT (XGLAPI *LoadPipeline)(XGL_DEVICE device, XGL_SIZE dataSize, const XGL_VOID* pData, XGL_PIPELINE* pPipeline);
    XGL_RESULT (XGLAPI *CreatePipelineDelta)(XGL_DEVICE device, XGL_PIPELINE p1, XGL_PIPELINE p2, XGL_PIPELINE_DELTA* delta);
    XGL_RESULT (XGLAPI *CreateSampler)(XGL_DEVICE device, const XGL_SAMPLER_CREATE_INFO* pCreateInfo, XGL_SAMPLER* pSampler);
    XGL_RESULT (XGLAPI *CreateDescriptorSet)(XGL_DEVICE device, const XGL_DESCRIPTOR_SET_CREATE_INFO* pCreateInfo, XGL_DESCRIPTOR_SET* pDescriptorSet);
    XGL_VOID (XGLAPI *BeginDescriptorSetUpdate)(XGL_DESCRIPTOR_SET descriptorSet);
    XGL_VOID (XGLAPI *EndDescriptorSetUpdate)(XGL_DESCRIPTOR_SET descriptorSet);
    XGL_VOID (XGLAPI *AttachSamplerDescriptors)(XGL_DESCRIPTOR_SET descriptorSet, XGL_UINT startSlot, XGL_UINT slotCount, const XGL_SAMPLER* pSamplers);
    XGL_VOID (XGLAPI *AttachImageViewDescriptors)(XGL_DESCRIPTOR_SET descriptorSet, XGL_UINT startSlot, XGL_UINT slotCount, const XGL_IMAGE_VIEW_ATTACH_INFO* pImageViews);
    XGL_VOID (XGLAPI *AttachMemoryViewDescriptors)(XGL_DESCRIPTOR_SET descriptorSet, XGL_UINT startSlot, XGL_UINT slotCount, const XGL_MEMORY_VIEW_ATTACH_INFO* pMemViews);
    XGL_VOID (XGLAPI *AttachNestedDescriptors)(XGL_DESCRIPTOR_SET descriptorSet, XGL_UINT startSlot, XGL_UINT slotCount, const XGL_DESCRIPTOR_SET_ATTACH_INFO* pNestedDescriptorSets);
    XGL_VOID (XGLAPI *ClearDescriptorSetSlots)(XGL_DESCRIPTOR_SET descriptorSet, XGL_UINT startSlot, XGL_UINT slotCount);
    XGL_RESULT (XGLAPI *CreateViewportState)(XGL_DEVICE device, const XGL_VIEWPORT_STATE_CREATE_INFO* pCreateInfo, XGL_VIEWPORT_STATE_OBJECT* pState);
    XGL_RESULT (XGLAPI *CreateRasterState)(XGL_DEVICE device, const XGL_RASTER_STATE_CREATE_INFO* pCreateInfo, XGL_RASTER_STATE_OBJECT* pState);
    XGL_RESULT (XGLAPI *CreateMsaaState)(XGL_DEVICE device, const XGL_MSAA_STATE_CREATE_INFO* pCreateInfo, XGL_MSAA_STATE_OBJECT* pState);
    XGL_RESULT (XGLAPI *CreateColorBlendState)(XGL_DEVICE device, const XGL_COLOR_BLEND_STATE_CREATE_INFO* pCreateInfo, XGL_COLOR_BLEND_STATE_OBJECT* pState);
    XGL_RESULT (XGLAPI *CreateDepthStencilState)(XGL_DEVICE device, const XGL_DEPTH_STENCIL_STATE_CREATE_INFO* pCreateInfo, XGL_DEPTH_STENCIL_STATE_OBJECT* pState);
    XGL_RESULT (XGLAPI *CreateCommandBuffer)(XGL_DEVICE device, const XGL_CMD_BUFFER_CREATE_INFO* pCreateInfo, XGL_CMD_BUFFER* pCmdBuffer);
    XGL_RESULT (XGLAPI *BeginCommandBuffer)(XGL_CMD_BUFFER cmdBuffer, XGL_FLAGS flags);
    XGL_RESULT (XGLAPI *EndCommandBuffer)(XGL_CMD_BUFFER cmdBuffer);
    XGL_RESULT (XGLAPI *ResetCommandBuffer)(XGL_CMD_BUFFER cmdBuffer);
    XGL_VOID (XGLAPI *CmdBindPipeline)(XGL_CMD_BUFFER cmdBuffer, XGL_PIPELINE_BIND_POINT pipelineBindPoint, XGL_PIPELINE pipeline);
    XGL_VOID (XGLAPI *CmdBindPipelineDelta)(XGL_CMD_BUFFER cmdBuffer, XGL_PIPELINE_BIND_POINT pipelineBindPoint, XGL_PIPELINE_DELTA delta);
    XGL_VOID (XGLAPI *CmdBindStateObject)(XGL_CMD_BUFFER cmdBuffer, XGL_STATE_BIND_POINT stateBindPoint, XGL_STATE_OBJECT state);
    XGL_VOID (XGLAPI *CmdBindDescriptorSet)(XGL_CMD_BUFFER cmdBuffer, XGL_PIPELINE_BIND_POINT pipelineBindPoint, XGL_UINT index, XGL_DESCRIPTOR_SET descriptorSet, XGL_UINT slotOffset);
    XGL_VOID (XGLAPI *CmdBindDynamicMemoryView)(XGL_CMD_BUFFER cmdBuffer, XGL_PIPELINE_BIND_POINT pipelineBindPoint, const XGL_MEMORY_VIEW_ATTACH_INFO* pMemView);
    XGL_VOID (XGLAPI *CmdBindIndexData)(XGL_CMD_BUFFER cmdBuffer, XGL_GPU_MEMORY mem, XGL_GPU_SIZE offset, XGL_INDEX_TYPE indexType);
    XGL_VOID (XGLAPI *CmdBindAttachments)(XGL_CMD_BUFFER cmdBuffer, XGL_UINT colorAttachmentCount, const XGL_COLOR_ATTACHMENT_BIND_INFO* pColorAttachments, const XGL_DEPTH_STENCIL_BIND_INFO* pDepthStencilAttachment);
    XGL_VOID (XGLAPI *CmdPrepareMemoryRegions)(XGL_CMD_BUFFER cmdBuffer, XGL_UINT transitionCount, const XGL_MEMORY_STATE_TRANSITION* pStateTransitions);
    XGL_VOID (XGLAPI *CmdPrepareImages)(XGL_CMD_BUFFER cmdBuffer, XGL_UINT transitionCount, const XGL_IMAGE_STATE_TRANSITION* pStateTransitions);
    XGL_VOID (XGLAPI *CmdDraw)(XGL_CMD_BUFFER cmdBuffer, XGL_UINT firstVertex, XGL_UINT vertexCount, XGL_UINT firstInstance, XGL_UINT instanceCount);
    XGL_VOID (XGLAPI *CmdDrawIndexed)(XGL_CMD_BUFFER cmdBuffer, XGL_UINT firstIndex, XGL_UINT indexCount, XGL_INT vertexOffset, XGL_UINT firstInstance, XGL_UINT instanceCount);
    XGL_VOID (XGLAPI *CmdDrawIndirect)(XGL_CMD_BUFFER cmdBuffer, XGL_GPU_MEMORY mem, XGL_GPU_SIZE offset, XGL_UINT32 count, XGL_UINT32 stride);
    XGL_VOID (XGLAPI *CmdDrawIndexedIndirect)(XGL_CMD_BUFFER cmdBuffer, XGL_GPU_MEMORY mem, XGL_GPU_SIZE offset, XGL_UINT32 count, XGL_UINT32 stride);
    XGL_VOID (XGLAPI *CmdDispatch)(XGL_CMD_BUFFER cmdBuffer, XGL_UINT x, XGL_UINT y, XGL_UINT z);
    XGL_VOID (XGLAPI *CmdDispatchIndirect)(XGL_CMD_BUFFER cmdBuffer, XGL_GPU_MEMORY mem, XGL_GPU_SIZE offset);
    XGL_VOID (XGLAPI *CmdCopyMemory)(XGL_CMD_BUFFER cmdBuffer, XGL_GPU_MEMORY srcMem, XGL_GPU_MEMORY destMem, XGL_UINT regionCount, const XGL_MEMORY_COPY* pRegions);
    XGL_VOID (XGLAPI *CmdCopyImage)(XGL_CMD_BUFFER cmdBuffer, XGL_IMAGE srcImage, XGL_IMAGE destImage, XGL_UINT regionCount, const XGL_IMAGE_COPY* pRegions);
    XGL_VOID (XGLAPI *CmdCopyMemoryToImage)(XGL_CMD_BUFFER cmdBuffer, XGL_GPU_MEMORY srcMem, XGL_IMAGE destImage, XGL_UINT regionCount, const XGL_MEMORY_IMAGE_COPY* pRegions);
    XGL_VOID (XGLAPI *CmdCopyImageToMemory)(XGL_CMD_BUFFER cmdBuffer, XGL_IMAGE srcImage, XGL_GPU_MEMORY destMem, XGL_UINT regionCount, const XGL_MEMORY_IMAGE_COPY* pRegions);
    XGL_VOID (XGLAPI *CmdCloneImageData)(XGL_CMD_BUFFER cmdBuffer, XGL_IMAGE srcImage, XGL_IMAGE_STATE srcImageState, XGL_IMAGE destImage, XGL_IMAGE_STATE destImageState);
    XGL_VOID (XGLAPI *CmdUpdateMemory)(XGL_CMD_BUFFER cmdBuffer, XGL_GPU_MEMORY destMem, XGL_GPU_SIZE destOffset, XGL_GPU_SIZE dataSize, const XGL_UINT32* pData);
    XGL_VOID (XGLAPI *CmdFillMemory)(XGL_CMD_BUFFER cmdBuffer, XGL_GPU_MEMORY destMem, XGL_GPU_SIZE destOffset, XGL_GPU_SIZE fillSize, XGL_UINT32 data);
    XGL_VOID (XGLAPI *CmdClearColorImage)(XGL_CMD_BUFFER cmdBuffer, XGL_IMAGE image, const XGL_FLOAT color[4], XGL_UINT rangeCount, const XGL_IMAGE_SUBRESOURCE_RANGE* pRanges);
    XGL_VOID (XGLAPI *CmdClearColorImageRaw)(XGL_CMD_BUFFER cmdBuffer, XGL_IMAGE image, const XGL_UINT32 color[4], XGL_UINT rangeCount, const XGL_IMAGE_SUBRESOURCE_RANGE* pRanges);
    XGL_VOID (XGLAPI *CmdClearDepthStencil)(XGL_CMD_BUFFER cmdBuffer, XGL_IMAGE image, XGL_FLOAT depth, XGL_UINT32 stencil, XGL_UINT rangeCount, const XGL_IMAGE_SUBRESOURCE_RANGE* pRanges);
    XGL_VOID (XGLAPI *CmdResolveImage)(XGL_CMD_BUFFER cmdBuffer, XGL_IMAGE srcImage, XGL_IMAGE destImage, XGL_UINT rectCount, const XGL_IMAGE_RESOLVE* pRects);
    XGL_VOID (XGLAPI *CmdSetEvent)(XGL_CMD_BUFFER cmdBuffer, XGL_EVENT event);
    XGL_VOID (XGLAPI *CmdResetEvent)(XGL_CMD_BUFFER cmdBuffer, XGL_EVENT event);
    XGL_VOID (XGLAPI *CmdMemoryAtomic)(XGL_CMD_BUFFER cmdBuffer, XGL_GPU_MEMORY destMem, XGL_GPU_SIZE destOffset, XGL_UINT64 srcData, XGL_ATOMIC_OP atomicOp);
    XGL_VOID (XGLAPI *CmdBeginQuery)(XGL_CMD_BUFFER cmdBuffer, XGL_QUERY_POOL queryPool, XGL_UINT slot, XGL_FLAGS flags);
    XGL_VOID (XGLAPI *CmdEndQuery)(XGL_CMD_BUFFER cmdBuffer, XGL_QUERY_POOL queryPool, XGL_UINT slot);
    XGL_VOID (XGLAPI *CmdResetQueryPool)(XGL_CMD_BUFFER cmdBuffer, XGL_QUERY_POOL queryPool, XGL_UINT startQuery, XGL_UINT queryCount);
    XGL_VOID (XGLAPI *CmdWriteTimestamp)(XGL_CMD_BUFFER cmdBuffer, XGL_TIMESTAMP_TYPE timestampType, XGL_GPU_MEMORY destMem, XGL_GPU_SIZE destOffset);
    XGL_VOID (XGLAPI *CmdInitAtomicCounters)(XGL_CMD_BUFFER cmdBuffer, XGL_PIPELINE_BIND_POINT pipelineBindPoint, XGL_UINT startCounter, XGL_UINT counterCount, const XGL_UINT32* pData);
    XGL_VOID (XGLAPI *CmdLoadAtomicCounters)(XGL_CMD_BUFFER cmdBuffer, XGL_PIPELINE_BIND_POINT pipelineBindPoint, XGL_UINT startCounter, XGL_UINT counterCount, XGL_GPU_MEMORY srcMem, XGL_GPU_SIZE srcOffset);
    XGL_VOID (XGLAPI *CmdSaveAtomicCounters)(XGL_CMD_BUFFER cmdBuffer, XGL_PIPELINE_BIND_POINT pipelineBindPoint, XGL_UINT startCounter, XGL_UINT counterCount, XGL_GPU_MEMORY destMem, XGL_GPU_SIZE destOffset);
    XGL_RESULT (XGLAPI *DbgSetValidationLevel)(XGL_DEVICE device, XGL_VALIDATION_LEVEL validationLevel);
    XGL_RESULT (XGLAPI *DbgRegisterMsgCallback)(XGL_DBG_MSG_CALLBACK_FUNCTION pfnMsgCallback, XGL_VOID* pUserData);
    XGL_RESULT (XGLAPI *DbgUnregisterMsgCallback)(XGL_DBG_MSG_CALLBACK_FUNCTION pfnMsgCallback);
    XGL_RESULT (XGLAPI *DbgSetMessageFilter)(XGL_DEVICE device, XGL_INT msgCode, XGL_DBG_MSG_FILTER filter);
    XGL_RESULT (XGLAPI *DbgSetObjectTag)(XGL_BASE_OBJECT object, XGL_SIZE tagSize, const XGL_VOID* pTag);
    XGL_RESULT (XGLAPI *DbgSetGlobalOption)(XGL_DBG_GLOBAL_OPTION dbgOption, XGL_SIZE dataSize, const XGL_VOID* pData);
    XGL_RESULT (XGLAPI *DbgSetDeviceOption)(XGL_DEVICE device, XGL_DBG_DEVICE_OPTION dbgOption, XGL_SIZE dataSize, const XGL_VOID* pData);
    XGL_VOID (XGLAPI *CmdDbgMarkerBegin)(XGL_CMD_BUFFER cmdBuffer, const XGL_CHAR* pMarker);
    XGL_VOID (XGLAPI *CmdDbgMarkerEnd)(XGL_CMD_BUFFER cmdBuffer);
};

XGL_RESULT XGLAPI xglGetGpuInfo(XGL_PHYSICAL_GPU gpu, XGL_PHYSICAL_GPU_INFO_TYPE infoType, XGL_SIZE* pDataSize, XGL_VOID* pData)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) gpu;
    return (*disp)->GetGpuInfo(gpu, infoType, pDataSize, pData);
}

XGL_RESULT XGLAPI xglCreateDevice(XGL_PHYSICAL_GPU gpu, const XGL_DEVICE_CREATE_INFO* pCreateInfo, XGL_DEVICE* pDevice)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) gpu;
    return (*disp)->CreateDevice(gpu, pCreateInfo, pDevice);
}

XGL_RESULT XGLAPI xglDestroyDevice(XGL_DEVICE device)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->DestroyDevice(device);
}

XGL_RESULT XGLAPI xglGetExtensionSupport(XGL_PHYSICAL_GPU gpu, const XGL_CHAR* pExtName)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) gpu;
    return (*disp)->GetExtensionSupport(gpu, pExtName);
}

XGL_RESULT XGLAPI xglGetDeviceQueue(XGL_DEVICE device, XGL_QUEUE_TYPE queueType, XGL_UINT queueIndex, XGL_QUEUE* pQueue)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->GetDeviceQueue(device, queueType, queueIndex, pQueue);
}

XGL_RESULT XGLAPI xglQueueSubmit(XGL_QUEUE queue, XGL_UINT cmdBufferCount, const XGL_CMD_BUFFER* pCmdBuffers, XGL_UINT memRefCount, const XGL_MEMORY_REF* pMemRefs, XGL_FENCE fence)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) queue;
    return (*disp)->QueueSubmit(queue, cmdBufferCount, pCmdBuffers, memRefCount, pMemRefs, fence);
}

XGL_RESULT XGLAPI xglQueueSetGlobalMemReferences(XGL_QUEUE queue, XGL_UINT memRefCount, const XGL_MEMORY_REF* pMemRefs)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) queue;
    return (*disp)->QueueSetGlobalMemReferences(queue, memRefCount, pMemRefs);
}

XGL_RESULT XGLAPI xglQueueWaitIdle(XGL_QUEUE queue)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) queue;
    return (*disp)->QueueWaitIdle(queue);
}

XGL_RESULT XGLAPI xglDeviceWaitIdle(XGL_DEVICE device)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->DeviceWaitIdle(device);
}

XGL_RESULT XGLAPI xglGetMemoryHeapCount(XGL_DEVICE device, XGL_UINT* pCount)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->GetMemoryHeapCount(device, pCount);
}

XGL_RESULT XGLAPI xglGetMemoryHeapInfo(XGL_DEVICE device, XGL_UINT heapId, XGL_MEMORY_HEAP_INFO_TYPE infoType, XGL_SIZE* pDataSize, XGL_VOID* pData)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->GetMemoryHeapInfo(device, heapId, infoType, pDataSize, pData);
}

XGL_RESULT XGLAPI xglAllocMemory(XGL_DEVICE device, const XGL_MEMORY_ALLOC_INFO* pAllocInfo, XGL_GPU_MEMORY* pMem)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->AllocMemory(device, pAllocInfo, pMem);
}

XGL_RESULT XGLAPI xglFreeMemory(XGL_GPU_MEMORY mem)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) mem;
    return (*disp)->FreeMemory(mem);
}

XGL_RESULT XGLAPI xglSetMemoryPriority(XGL_GPU_MEMORY mem, XGL_MEMORY_PRIORITY priority)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) mem;
    return (*disp)->SetMemoryPriority(mem, priority);
}

XGL_RESULT XGLAPI xglMapMemory(XGL_GPU_MEMORY mem, XGL_FLAGS flags, XGL_VOID** ppData)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) mem;
    return (*disp)->MapMemory(mem, flags, ppData);
}

XGL_RESULT XGLAPI xglUnmapMemory(XGL_GPU_MEMORY mem)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) mem;
    return (*disp)->UnmapMemory(mem);
}

XGL_RESULT XGLAPI xglPinSystemMemory(XGL_DEVICE device, const XGL_VOID* pSysMem, XGL_SIZE memSize, XGL_GPU_MEMORY* pMem)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->PinSystemMemory(device, pSysMem, memSize, pMem);
}

XGL_RESULT XGLAPI xglRemapVirtualMemoryPages(XGL_DEVICE device, XGL_UINT rangeCount, const XGL_VIRTUAL_MEMORY_REMAP_RANGE* pRanges, XGL_UINT preWaitSemaphoreCount, const XGL_QUEUE_SEMAPHORE* pPreWaitSemaphores, XGL_UINT postSignalSemaphoreCount, const XGL_QUEUE_SEMAPHORE* pPostSignalSemaphores)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->RemapVirtualMemoryPages(device, rangeCount, pRanges, preWaitSemaphoreCount, pPreWaitSemaphores, postSignalSemaphoreCount, pPostSignalSemaphores);
}

XGL_RESULT XGLAPI xglGetMultiGpuCompatibility(XGL_PHYSICAL_GPU gpu0, XGL_PHYSICAL_GPU gpu1, XGL_GPU_COMPATIBILITY_INFO* pInfo)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) gpu0;
    return (*disp)->GetMultiGpuCompatibility(gpu0, gpu1, pInfo);
}

XGL_RESULT XGLAPI xglOpenSharedMemory(XGL_DEVICE device, const XGL_MEMORY_OPEN_INFO* pOpenInfo, XGL_GPU_MEMORY* pMem)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->OpenSharedMemory(device, pOpenInfo, pMem);
}

XGL_RESULT XGLAPI xglOpenSharedQueueSemaphore(XGL_DEVICE device, const XGL_QUEUE_SEMAPHORE_OPEN_INFO* pOpenInfo, XGL_QUEUE_SEMAPHORE* pSemaphore)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->OpenSharedQueueSemaphore(device, pOpenInfo, pSemaphore);
}

XGL_RESULT XGLAPI xglOpenPeerMemory(XGL_DEVICE device, const XGL_PEER_MEMORY_OPEN_INFO* pOpenInfo, XGL_GPU_MEMORY* pMem)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->OpenPeerMemory(device, pOpenInfo, pMem);
}

XGL_RESULT XGLAPI xglOpenPeerImage(XGL_DEVICE device, const XGL_PEER_IMAGE_OPEN_INFO* pOpenInfo, XGL_IMAGE* pImage, XGL_GPU_MEMORY* pMem)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->OpenPeerImage(device, pOpenInfo, pImage, pMem);
}

XGL_RESULT XGLAPI xglDestroyObject(XGL_OBJECT object)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) object;
    return (*disp)->DestroyObject(object);
}

XGL_RESULT XGLAPI xglGetObjectInfo(XGL_BASE_OBJECT object, XGL_OBJECT_INFO_TYPE infoType, XGL_SIZE* pDataSize, XGL_VOID* pData)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) object;
    return (*disp)->GetObjectInfo(object, infoType, pDataSize, pData);
}

XGL_RESULT XGLAPI xglBindObjectMemory(XGL_OBJECT object, XGL_GPU_MEMORY mem, XGL_GPU_SIZE offset)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) object;
    return (*disp)->BindObjectMemory(object, mem, offset);
}

XGL_RESULT XGLAPI xglCreateFence(XGL_DEVICE device, const XGL_FENCE_CREATE_INFO* pCreateInfo, XGL_FENCE* pFence)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreateFence(device, pCreateInfo, pFence);
}

XGL_RESULT XGLAPI xglGetFenceStatus(XGL_FENCE fence)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) fence;
    return (*disp)->GetFenceStatus(fence);
}

XGL_RESULT XGLAPI xglWaitForFences(XGL_DEVICE device, XGL_UINT fenceCount, const XGL_FENCE* pFences, XGL_BOOL waitAll, XGL_UINT64 timeout)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->WaitForFences(device, fenceCount, pFences, waitAll, timeout);
}

XGL_RESULT XGLAPI xglCreateQueueSemaphore(XGL_DEVICE device, const XGL_QUEUE_SEMAPHORE_CREATE_INFO* pCreateInfo, XGL_QUEUE_SEMAPHORE* pSemaphore)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreateQueueSemaphore(device, pCreateInfo, pSemaphore);
}

XGL_RESULT XGLAPI xglSignalQueueSemaphore(XGL_QUEUE queue, XGL_QUEUE_SEMAPHORE semaphore)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) queue;
    return (*disp)->SignalQueueSemaphore(queue, semaphore);
}

XGL_RESULT XGLAPI xglWaitQueueSemaphore(XGL_QUEUE queue, XGL_QUEUE_SEMAPHORE semaphore)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) queue;
    return (*disp)->WaitQueueSemaphore(queue, semaphore);
}

XGL_RESULT XGLAPI xglCreateEvent(XGL_DEVICE device, const XGL_EVENT_CREATE_INFO* pCreateInfo, XGL_EVENT* pEvent)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreateEvent(device, pCreateInfo, pEvent);
}

XGL_RESULT XGLAPI xglGetEventStatus(XGL_EVENT event)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) event;
    return (*disp)->GetEventStatus(event);
}

XGL_RESULT XGLAPI xglSetEvent(XGL_EVENT event)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) event;
    return (*disp)->SetEvent(event);
}

XGL_RESULT XGLAPI xglResetEvent(XGL_EVENT event)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) event;
    return (*disp)->ResetEvent(event);
}

XGL_RESULT XGLAPI xglCreateQueryPool(XGL_DEVICE device, const XGL_QUERY_POOL_CREATE_INFO* pCreateInfo, XGL_QUERY_POOL* pQueryPool)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreateQueryPool(device, pCreateInfo, pQueryPool);
}

XGL_RESULT XGLAPI xglGetQueryPoolResults(XGL_QUERY_POOL queryPool, XGL_UINT startQuery, XGL_UINT queryCount, XGL_SIZE* pDataSize, XGL_VOID* pData)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) queryPool;
    return (*disp)->GetQueryPoolResults(queryPool, startQuery, queryCount, pDataSize, pData);
}

XGL_RESULT XGLAPI xglGetFormatInfo(XGL_DEVICE device, XGL_FORMAT format, XGL_FORMAT_INFO_TYPE infoType, XGL_SIZE* pDataSize, XGL_VOID* pData)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->GetFormatInfo(device, format, infoType, pDataSize, pData);
}

XGL_RESULT XGLAPI xglCreateImage(XGL_DEVICE device, const XGL_IMAGE_CREATE_INFO* pCreateInfo, XGL_IMAGE* pImage)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreateImage(device, pCreateInfo, pImage);
}

XGL_RESULT XGLAPI xglGetImageSubresourceInfo(XGL_IMAGE image, const XGL_IMAGE_SUBRESOURCE* pSubresource, XGL_SUBRESOURCE_INFO_TYPE infoType, XGL_SIZE* pDataSize, XGL_VOID* pData)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) image;
    return (*disp)->GetImageSubresourceInfo(image, pSubresource, infoType, pDataSize, pData);
}

XGL_RESULT XGLAPI xglCreateImageView(XGL_DEVICE device, const XGL_IMAGE_VIEW_CREATE_INFO* pCreateInfo, XGL_IMAGE_VIEW* pView)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreateImageView(device, pCreateInfo, pView);
}

XGL_RESULT XGLAPI xglCreateColorAttachmentView(XGL_DEVICE device, const XGL_COLOR_ATTACHMENT_VIEW_CREATE_INFO* pCreateInfo, XGL_COLOR_ATTACHMENT_VIEW* pView)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreateColorAttachmentView(device, pCreateInfo, pView);
}

XGL_RESULT XGLAPI xglCreateDepthStencilView(XGL_DEVICE device, const XGL_DEPTH_STENCIL_VIEW_CREATE_INFO* pCreateInfo, XGL_DEPTH_STENCIL_VIEW* pView)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreateDepthStencilView(device, pCreateInfo, pView);
}

XGL_RESULT XGLAPI xglCreateShader(XGL_DEVICE device, const XGL_SHADER_CREATE_INFO* pCreateInfo, XGL_SHADER* pShader)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreateShader(device, pCreateInfo, pShader);
}

XGL_RESULT XGLAPI xglCreateGraphicsPipeline(XGL_DEVICE device, const XGL_GRAPHICS_PIPELINE_CREATE_INFO* pCreateInfo, XGL_PIPELINE* pPipeline)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreateGraphicsPipeline(device, pCreateInfo, pPipeline);
}

XGL_RESULT XGLAPI xglCreateComputePipeline(XGL_DEVICE device, const XGL_COMPUTE_PIPELINE_CREATE_INFO* pCreateInfo, XGL_PIPELINE* pPipeline)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreateComputePipeline(device, pCreateInfo, pPipeline);
}

XGL_RESULT XGLAPI xglStorePipeline(XGL_PIPELINE pipeline, XGL_SIZE* pDataSize, XGL_VOID* pData)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) pipeline;
    return (*disp)->StorePipeline(pipeline, pDataSize, pData);
}

XGL_RESULT XGLAPI xglLoadPipeline(XGL_DEVICE device, XGL_SIZE dataSize, const XGL_VOID* pData, XGL_PIPELINE* pPipeline)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->LoadPipeline(device, dataSize, pData, pPipeline);
}

XGL_RESULT XGLAPI xglCreatePipelineDelta(XGL_DEVICE device, XGL_PIPELINE p1, XGL_PIPELINE p2, XGL_PIPELINE_DELTA* delta)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreatePipelineDelta(device, p1, p2, delta);
}

XGL_RESULT XGLAPI xglCreateSampler(XGL_DEVICE device, const XGL_SAMPLER_CREATE_INFO* pCreateInfo, XGL_SAMPLER* pSampler)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreateSampler(device, pCreateInfo, pSampler);
}

XGL_RESULT XGLAPI xglCreateDescriptorSet(XGL_DEVICE device, const XGL_DESCRIPTOR_SET_CREATE_INFO* pCreateInfo, XGL_DESCRIPTOR_SET* pDescriptorSet)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreateDescriptorSet(device, pCreateInfo, pDescriptorSet);
}

XGL_VOID XGLAPI xglBeginDescriptorSetUpdate(XGL_DESCRIPTOR_SET descriptorSet)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) descriptorSet;
    (*disp)->BeginDescriptorSetUpdate(descriptorSet);
}

XGL_VOID XGLAPI xglEndDescriptorSetUpdate(XGL_DESCRIPTOR_SET descriptorSet)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) descriptorSet;
    (*disp)->EndDescriptorSetUpdate(descriptorSet);
}

XGL_VOID XGLAPI xglAttachSamplerDescriptors(XGL_DESCRIPTOR_SET descriptorSet, XGL_UINT startSlot, XGL_UINT slotCount, const XGL_SAMPLER* pSamplers)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) descriptorSet;
    (*disp)->AttachSamplerDescriptors(descriptorSet, startSlot, slotCount, pSamplers);
}

XGL_VOID XGLAPI xglAttachImageViewDescriptors(XGL_DESCRIPTOR_SET descriptorSet, XGL_UINT startSlot, XGL_UINT slotCount, const XGL_IMAGE_VIEW_ATTACH_INFO* pImageViews)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) descriptorSet;
    (*disp)->AttachImageViewDescriptors(descriptorSet, startSlot, slotCount, pImageViews);
}

XGL_VOID XGLAPI xglAttachMemoryViewDescriptors(XGL_DESCRIPTOR_SET descriptorSet, XGL_UINT startSlot, XGL_UINT slotCount, const XGL_MEMORY_VIEW_ATTACH_INFO* pMemViews)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) descriptorSet;
    (*disp)->AttachMemoryViewDescriptors(descriptorSet, startSlot, slotCount, pMemViews);
}

XGL_VOID XGLAPI xglAttachNestedDescriptors(XGL_DESCRIPTOR_SET descriptorSet, XGL_UINT startSlot, XGL_UINT slotCount, const XGL_DESCRIPTOR_SET_ATTACH_INFO* pNestedDescriptorSets)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) descriptorSet;
    (*disp)->AttachNestedDescriptors(descriptorSet, startSlot, slotCount, pNestedDescriptorSets);
}

XGL_VOID XGLAPI xglClearDescriptorSetSlots(XGL_DESCRIPTOR_SET descriptorSet, XGL_UINT startSlot, XGL_UINT slotCount)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) descriptorSet;
    (*disp)->ClearDescriptorSetSlots(descriptorSet, startSlot, slotCount);
}

XGL_RESULT XGLAPI xglCreateViewportState(XGL_DEVICE device, const XGL_VIEWPORT_STATE_CREATE_INFO* pCreateInfo, XGL_VIEWPORT_STATE_OBJECT* pState)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreateViewportState(device, pCreateInfo, pState);
}

XGL_RESULT XGLAPI xglCreateRasterState(XGL_DEVICE device, const XGL_RASTER_STATE_CREATE_INFO* pCreateInfo, XGL_RASTER_STATE_OBJECT* pState)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreateRasterState(device, pCreateInfo, pState);
}

XGL_RESULT XGLAPI xglCreateMsaaState(XGL_DEVICE device, const XGL_MSAA_STATE_CREATE_INFO* pCreateInfo, XGL_MSAA_STATE_OBJECT* pState)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreateMsaaState(device, pCreateInfo, pState);
}

XGL_RESULT XGLAPI xglCreateColorBlendState(XGL_DEVICE device, const XGL_COLOR_BLEND_STATE_CREATE_INFO* pCreateInfo, XGL_COLOR_BLEND_STATE_OBJECT* pState)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreateColorBlendState(device, pCreateInfo, pState);
}

XGL_RESULT XGLAPI xglCreateDepthStencilState(XGL_DEVICE device, const XGL_DEPTH_STENCIL_STATE_CREATE_INFO* pCreateInfo, XGL_DEPTH_STENCIL_STATE_OBJECT* pState)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreateDepthStencilState(device, pCreateInfo, pState);
}

XGL_RESULT XGLAPI xglCreateCommandBuffer(XGL_DEVICE device, const XGL_CMD_BUFFER_CREATE_INFO* pCreateInfo, XGL_CMD_BUFFER* pCmdBuffer)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->CreateCommandBuffer(device, pCreateInfo, pCmdBuffer);
}

XGL_RESULT XGLAPI xglBeginCommandBuffer(XGL_CMD_BUFFER cmdBuffer, XGL_FLAGS flags)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    return (*disp)->BeginCommandBuffer(cmdBuffer, flags);
}

XGL_RESULT XGLAPI xglEndCommandBuffer(XGL_CMD_BUFFER cmdBuffer)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    return (*disp)->EndCommandBuffer(cmdBuffer);
}

XGL_RESULT XGLAPI xglResetCommandBuffer(XGL_CMD_BUFFER cmdBuffer)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    return (*disp)->ResetCommandBuffer(cmdBuffer);
}

XGL_VOID XGLAPI xglCmdBindPipeline(XGL_CMD_BUFFER cmdBuffer, XGL_PIPELINE_BIND_POINT pipelineBindPoint, XGL_PIPELINE pipeline)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdBindPipeline(cmdBuffer, pipelineBindPoint, pipeline);
}

XGL_VOID XGLAPI xglCmdBindPipelineDelta(XGL_CMD_BUFFER cmdBuffer, XGL_PIPELINE_BIND_POINT pipelineBindPoint, XGL_PIPELINE_DELTA delta)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdBindPipelineDelta(cmdBuffer, pipelineBindPoint, delta);
}

XGL_VOID XGLAPI xglCmdBindStateObject(XGL_CMD_BUFFER cmdBuffer, XGL_STATE_BIND_POINT stateBindPoint, XGL_STATE_OBJECT state)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdBindStateObject(cmdBuffer, stateBindPoint, state);
}

XGL_VOID XGLAPI xglCmdBindDescriptorSet(XGL_CMD_BUFFER cmdBuffer, XGL_PIPELINE_BIND_POINT pipelineBindPoint, XGL_UINT index, XGL_DESCRIPTOR_SET descriptorSet, XGL_UINT slotOffset)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdBindDescriptorSet(cmdBuffer, pipelineBindPoint, index, descriptorSet, slotOffset);
}

XGL_VOID XGLAPI xglCmdBindDynamicMemoryView(XGL_CMD_BUFFER cmdBuffer, XGL_PIPELINE_BIND_POINT pipelineBindPoint, const XGL_MEMORY_VIEW_ATTACH_INFO* pMemView)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdBindDynamicMemoryView(cmdBuffer, pipelineBindPoint, pMemView);
}

XGL_VOID XGLAPI xglCmdBindIndexData(XGL_CMD_BUFFER cmdBuffer, XGL_GPU_MEMORY mem, XGL_GPU_SIZE offset, XGL_INDEX_TYPE indexType)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdBindIndexData(cmdBuffer, mem, offset, indexType);
}

XGL_VOID XGLAPI xglCmdBindAttachments(XGL_CMD_BUFFER cmdBuffer, XGL_UINT colorAttachmentCount, const XGL_COLOR_ATTACHMENT_BIND_INFO* pColorAttachments, const XGL_DEPTH_STENCIL_BIND_INFO* pDepthStencilAttachment)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdBindAttachments(cmdBuffer, colorAttachmentCount, pColorAttachments, pDepthStencilAttachment);
}

XGL_VOID XGLAPI xglCmdPrepareMemoryRegions(XGL_CMD_BUFFER cmdBuffer, XGL_UINT transitionCount, const XGL_MEMORY_STATE_TRANSITION* pStateTransitions)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdPrepareMemoryRegions(cmdBuffer, transitionCount, pStateTransitions);
}

XGL_VOID XGLAPI xglCmdPrepareImages(XGL_CMD_BUFFER cmdBuffer, XGL_UINT transitionCount, const XGL_IMAGE_STATE_TRANSITION* pStateTransitions)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdPrepareImages(cmdBuffer, transitionCount, pStateTransitions);
}

XGL_VOID XGLAPI xglCmdDraw(XGL_CMD_BUFFER cmdBuffer, XGL_UINT firstVertex, XGL_UINT vertexCount, XGL_UINT firstInstance, XGL_UINT instanceCount)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdDraw(cmdBuffer, firstVertex, vertexCount, firstInstance, instanceCount);
}

XGL_VOID XGLAPI xglCmdDrawIndexed(XGL_CMD_BUFFER cmdBuffer, XGL_UINT firstIndex, XGL_UINT indexCount, XGL_INT vertexOffset, XGL_UINT firstInstance, XGL_UINT instanceCount)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdDrawIndexed(cmdBuffer, firstIndex, indexCount, vertexOffset, firstInstance, instanceCount);
}

XGL_VOID XGLAPI xglCmdDrawIndirect(XGL_CMD_BUFFER cmdBuffer, XGL_GPU_MEMORY mem, XGL_GPU_SIZE offset, XGL_UINT32 count, XGL_UINT32 stride)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdDrawIndirect(cmdBuffer, mem, offset, count, stride);
}

XGL_VOID XGLAPI xglCmdDrawIndexedIndirect(XGL_CMD_BUFFER cmdBuffer, XGL_GPU_MEMORY mem, XGL_GPU_SIZE offset, XGL_UINT32 count, XGL_UINT32 stride)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdDrawIndexedIndirect(cmdBuffer, mem, offset, count, stride);
}

XGL_VOID XGLAPI xglCmdDispatch(XGL_CMD_BUFFER cmdBuffer, XGL_UINT x, XGL_UINT y, XGL_UINT z)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdDispatch(cmdBuffer, x, y, z);
}

XGL_VOID XGLAPI xglCmdDispatchIndirect(XGL_CMD_BUFFER cmdBuffer, XGL_GPU_MEMORY mem, XGL_GPU_SIZE offset)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdDispatchIndirect(cmdBuffer, mem, offset);
}

XGL_VOID XGLAPI xglCmdCopyMemory(XGL_CMD_BUFFER cmdBuffer, XGL_GPU_MEMORY srcMem, XGL_GPU_MEMORY destMem, XGL_UINT regionCount, const XGL_MEMORY_COPY* pRegions)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdCopyMemory(cmdBuffer, srcMem, destMem, regionCount, pRegions);
}

XGL_VOID XGLAPI xglCmdCopyImage(XGL_CMD_BUFFER cmdBuffer, XGL_IMAGE srcImage, XGL_IMAGE destImage, XGL_UINT regionCount, const XGL_IMAGE_COPY* pRegions)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdCopyImage(cmdBuffer, srcImage, destImage, regionCount, pRegions);
}

XGL_VOID XGLAPI xglCmdCopyMemoryToImage(XGL_CMD_BUFFER cmdBuffer, XGL_GPU_MEMORY srcMem, XGL_IMAGE destImage, XGL_UINT regionCount, const XGL_MEMORY_IMAGE_COPY* pRegions)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdCopyMemoryToImage(cmdBuffer, srcMem, destImage, regionCount, pRegions);
}

XGL_VOID XGLAPI xglCmdCopyImageToMemory(XGL_CMD_BUFFER cmdBuffer, XGL_IMAGE srcImage, XGL_GPU_MEMORY destMem, XGL_UINT regionCount, const XGL_MEMORY_IMAGE_COPY* pRegions)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdCopyImageToMemory(cmdBuffer, srcImage, destMem, regionCount, pRegions);
}

XGL_VOID XGLAPI xglCmdCloneImageData(XGL_CMD_BUFFER cmdBuffer, XGL_IMAGE srcImage, XGL_IMAGE_STATE srcImageState, XGL_IMAGE destImage, XGL_IMAGE_STATE destImageState)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdCloneImageData(cmdBuffer, srcImage, srcImageState, destImage, destImageState);
}

XGL_VOID XGLAPI xglCmdUpdateMemory(XGL_CMD_BUFFER cmdBuffer, XGL_GPU_MEMORY destMem, XGL_GPU_SIZE destOffset, XGL_GPU_SIZE dataSize, const XGL_UINT32* pData)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdUpdateMemory(cmdBuffer, destMem, destOffset, dataSize, pData);
}

XGL_VOID XGLAPI xglCmdFillMemory(XGL_CMD_BUFFER cmdBuffer, XGL_GPU_MEMORY destMem, XGL_GPU_SIZE destOffset, XGL_GPU_SIZE fillSize, XGL_UINT32 data)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdFillMemory(cmdBuffer, destMem, destOffset, fillSize, data);
}

XGL_VOID XGLAPI xglCmdClearColorImage(XGL_CMD_BUFFER cmdBuffer, XGL_IMAGE image, const XGL_FLOAT color[4], XGL_UINT rangeCount, const XGL_IMAGE_SUBRESOURCE_RANGE* pRanges)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdClearColorImage(cmdBuffer, image, color, rangeCount, pRanges);
}

XGL_VOID XGLAPI xglCmdClearColorImageRaw(XGL_CMD_BUFFER cmdBuffer, XGL_IMAGE image, const XGL_UINT32 color[4], XGL_UINT rangeCount, const XGL_IMAGE_SUBRESOURCE_RANGE* pRanges)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdClearColorImageRaw(cmdBuffer, image, color, rangeCount, pRanges);
}

XGL_VOID XGLAPI xglCmdClearDepthStencil(XGL_CMD_BUFFER cmdBuffer, XGL_IMAGE image, XGL_FLOAT depth, XGL_UINT32 stencil, XGL_UINT rangeCount, const XGL_IMAGE_SUBRESOURCE_RANGE* pRanges)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdClearDepthStencil(cmdBuffer, image, depth, stencil, rangeCount, pRanges);
}

XGL_VOID XGLAPI xglCmdResolveImage(XGL_CMD_BUFFER cmdBuffer, XGL_IMAGE srcImage, XGL_IMAGE destImage, XGL_UINT rectCount, const XGL_IMAGE_RESOLVE* pRects)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdResolveImage(cmdBuffer, srcImage, destImage, rectCount, pRects);
}

XGL_VOID XGLAPI xglCmdSetEvent(XGL_CMD_BUFFER cmdBuffer, XGL_EVENT event)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdSetEvent(cmdBuffer, event);
}

XGL_VOID XGLAPI xglCmdResetEvent(XGL_CMD_BUFFER cmdBuffer, XGL_EVENT event)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdResetEvent(cmdBuffer, event);
}

XGL_VOID XGLAPI xglCmdMemoryAtomic(XGL_CMD_BUFFER cmdBuffer, XGL_GPU_MEMORY destMem, XGL_GPU_SIZE destOffset, XGL_UINT64 srcData, XGL_ATOMIC_OP atomicOp)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdMemoryAtomic(cmdBuffer, destMem, destOffset, srcData, atomicOp);
}

XGL_VOID XGLAPI xglCmdBeginQuery(XGL_CMD_BUFFER cmdBuffer, XGL_QUERY_POOL queryPool, XGL_UINT slot, XGL_FLAGS flags)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdBeginQuery(cmdBuffer, queryPool, slot, flags);
}

XGL_VOID XGLAPI xglCmdEndQuery(XGL_CMD_BUFFER cmdBuffer, XGL_QUERY_POOL queryPool, XGL_UINT slot)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdEndQuery(cmdBuffer, queryPool, slot);
}

XGL_VOID XGLAPI xglCmdResetQueryPool(XGL_CMD_BUFFER cmdBuffer, XGL_QUERY_POOL queryPool, XGL_UINT startQuery, XGL_UINT queryCount)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdResetQueryPool(cmdBuffer, queryPool, startQuery, queryCount);
}

XGL_VOID XGLAPI xglCmdWriteTimestamp(XGL_CMD_BUFFER cmdBuffer, XGL_TIMESTAMP_TYPE timestampType, XGL_GPU_MEMORY destMem, XGL_GPU_SIZE destOffset)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdWriteTimestamp(cmdBuffer, timestampType, destMem, destOffset);
}

XGL_VOID XGLAPI xglCmdInitAtomicCounters(XGL_CMD_BUFFER cmdBuffer, XGL_PIPELINE_BIND_POINT pipelineBindPoint, XGL_UINT startCounter, XGL_UINT counterCount, const XGL_UINT32* pData)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdInitAtomicCounters(cmdBuffer, pipelineBindPoint, startCounter, counterCount, pData);
}

XGL_VOID XGLAPI xglCmdLoadAtomicCounters(XGL_CMD_BUFFER cmdBuffer, XGL_PIPELINE_BIND_POINT pipelineBindPoint, XGL_UINT startCounter, XGL_UINT counterCount, XGL_GPU_MEMORY srcMem, XGL_GPU_SIZE srcOffset)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdLoadAtomicCounters(cmdBuffer, pipelineBindPoint, startCounter, counterCount, srcMem, srcOffset);
}

XGL_VOID XGLAPI xglCmdSaveAtomicCounters(XGL_CMD_BUFFER cmdBuffer, XGL_PIPELINE_BIND_POINT pipelineBindPoint, XGL_UINT startCounter, XGL_UINT counterCount, XGL_GPU_MEMORY destMem, XGL_GPU_SIZE destOffset)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdSaveAtomicCounters(cmdBuffer, pipelineBindPoint, startCounter, counterCount, destMem, destOffset);
}

XGL_RESULT XGLAPI xglDbgSetValidationLevel(XGL_DEVICE device, XGL_VALIDATION_LEVEL validationLevel)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->DbgSetValidationLevel(device, validationLevel);
}

XGL_RESULT XGLAPI xglDbgSetMessageFilter(XGL_DEVICE device, XGL_INT msgCode, XGL_DBG_MSG_FILTER filter)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->DbgSetMessageFilter(device, msgCode, filter);
}

XGL_RESULT XGLAPI xglDbgSetObjectTag(XGL_BASE_OBJECT object, XGL_SIZE tagSize, const XGL_VOID* pTag)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) object;
    return (*disp)->DbgSetObjectTag(object, tagSize, pTag);
}

XGL_RESULT XGLAPI xglDbgSetDeviceOption(XGL_DEVICE device, XGL_DBG_DEVICE_OPTION dbgOption, XGL_SIZE dataSize, const XGL_VOID* pData)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) device;
    return (*disp)->DbgSetDeviceOption(device, dbgOption, dataSize, pData);
}

XGL_VOID XGLAPI xglCmdDbgMarkerBegin(XGL_CMD_BUFFER cmdBuffer, const XGL_CHAR* pMarker)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdDbgMarkerBegin(cmdBuffer, pMarker);
}

XGL_VOID XGLAPI xglCmdDbgMarkerEnd(XGL_CMD_BUFFER cmdBuffer)
{
    const struct icd_dispatch_table **disp = (const struct icd_dispatch_table **) cmdBuffer;
    (*disp)->CmdDbgMarkerEnd(cmdBuffer);
}
